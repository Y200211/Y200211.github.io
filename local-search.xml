<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL | 深入浅出索引</title>
    <link href="/2023/06/07/04%E8%AE%B2%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/"/>
    <url>/2023/06/07/04%E8%AE%B2%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>索引一般有三种常见的实现：哈希表，有序数组，N叉树</p><ul><li><p>哈希表</p><p>  一般是给一个想查的值，然后通过哈希函数算出来N，通过这个N就能取到想要的值。有时候两个数算出来都是N，这就是哈希冲突，这时就会在后面加一个链表。哈希表的增删改时间复杂度都是O(n)，但是区域查询会很麻烦，因为它是无序的，区域内的数每个都要查一次，所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如Memcached及其他一些NoSQL引擎。</p><p>  总结一下：</p><pre><code class="hljs">增删改的速度很快，等值查询也很快，但是范围查询不行</code></pre></li><li><p>有序数组</p><ul><li><p>优点：</p><p>  因为是有序的数组，所以查询的时候可以用二分法，时间复杂度是O(logN)，也很适合范围查询，先查最左面的数，然后依次往后遍历，一直查到右面的边界即可。</p></li><li><p>缺点：</p><p>  插入很麻烦，因为要维持有序性，所以当插入的数在数组中间的时候，后面的数都要依次向后面挪动，效率很低。</p></li></ul><p>  所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p></li></ul><p>上面这两种实现都有很明显的缺点，所以为了解决这些缺点，引出了第三种，请看下文。</p><ul><li><p>二叉搜索树：</p><p>  要说N叉树，先说说二叉搜索树树为什么不行。因为搜索树的查询时间复杂度是O(logN)，但是插入的复杂度也是O(logN)，那为什么不用二叉搜索树呢。因为我们的索引不止存在于内存中，还在磁盘中，而磁盘IO读取数据块的时间大约是10ms，所以我们应该减少对数据快的切换读取，所以引入了N叉树，B树，B+树。</p></li><li><p>N叉搜索树：</p><p>  就是俗称的B树，它的N一般是1200，也就是说他是1200叉树，当他的树高是4的时候，就可以存1200^3。</p></li><li><p><strong>B+树：</strong></p><p>  InnoDB中的索引模型，首先先解释一下B树和B+树的区别：</p><ul><li>B+树的数据都存在叶子结点，而B树的数据在各个节点，B+树这个行为更适合在磁盘储存这种外部储存模式，因为在每个节点都有数据会使得数据块存不下几个节点之后不得不分页，这导致了树的高度增加，磁盘IO次数增加，效率降低</li><li>B+树的叶子结点保证了有序性的同时，还用指针连接起来了，这保证了范围查询时不用反复查找，直接遍历即可。</li></ul></li></ul><p>说完了索引的底层存储类型，接下来看看实践过程中会遇到的一些问题。</p><p>先看看索引的简单分类：</p><ul><li>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。</li><li>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）。</li></ul><p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li>如果语句是select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索ID这棵B+树；</li><li>如果语句是select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><p>首先来讨论一下自增主键的作用：</p><ul><li>增加节点的时候，由于主键是自增主键，所以直接在尾巴添加即可，不需要在中间插入，会导致页分裂问题，而且自增主键占的位置也很小（和一般别的唯一索引相比）。删除同理，但是一般会使用伪删除，防止页合并发生。</li><li>主键所占得位置小还有一个好处，就是会节省非聚簇索引（非主键索引）的大小，因为其他的一般索引叶子结点都是主键（用于回表）。</li></ul><p>虽然自增主键有这么多好处，但是凡事不绝对，下面这个场景就使用非自增ID比较好：</p><ul><li>如果只有一个索引，并且这个索引是唯一索引，那么用这个唯一的字段作为主键比较好，因为避免了查两次表，如果要用自增ID的话，需要先查一下唯一的字段的索引来获取到自增ID，再用自增ID查看完整的数据。</li></ul><h2 id="覆盖索引和联合索引的区别"><a href="#覆盖索引和联合索引的区别" class="headerlink" title="覆盖索引和联合索引的区别"></a><strong>覆盖索引和联合索引的区别</strong></h2><ul><li>覆盖索引就是在二级索引中已经能拿到所需要的所有数据，不用回表，达成这个要求的就是覆盖索引，即使二级索引不是联合索引也可能达成。</li><li>联合索引就是把几个列合在一起构建一个索引，这样的索引更有可能达成覆盖索引，但是需要注意的是有最左前缀法则，查询的时候字段的顺序一定要注意。（最左原则的原理就是，因为联合索引的有序性是从左往右的优先度的，所以查的时候必须先从左边开始，否则用不了联合索引）</li></ul><h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>简单来说就是尽可能的提早把不符合条件的数据过滤掉，看下面的例子：</p><p>检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”</p><p><img src="https://secure2.wostatic.cn/static/pKWUQG4m83cLKN3rteUge7/image.png?auth_key=1686117385-iS2uPDMc7AXsJ2qiih4z46-0-e597a022c961068d58a12a8bf839f15f&file_size=258947"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL | 事务隔离</title>
    <link href="/2023/06/06/03%E8%AE%B2%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/"/>
    <url>/2023/06/06/03%E8%AE%B2%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<ul><li>首先先上广为人知的知识点：</li></ul><p>1、事务的特性：原子性（A）、一致性（C）、隔离性（I）、持久性（D）<br>2、多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读<br>3、事务隔离级别：读未提交、读提交、可重复读、串行化<br>4、不同事务隔离级别的区别：  </p><pre><code class="hljs">读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到  </code></pre><p>读提交：一个事务提交之后，它所做的变更才可以被别的事务看到<br>可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的<br>串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行</p><ul><li><p>四种隔离级别的实现方法：</p><ul><li>读未提交：直接返回最新值，没有视图的概念</li><li>读提交：每个SQL语句生成一个视图</li><li>可重复度：每个事务开始的时候生成一个视图，一直用到事务结束</li><li>串行化：简单来说就是加锁，用加锁的方式避免并行操作</li></ul></li><li><p>四种隔离级别具体的使用场景：</p><ul><li>01: Read uncommitted 读未提交; 公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有2000元，singo空欢喜一场。</li><li>02:Read committed 读已提交; singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何……</li><li>03:Repeatable read 重复读 当singo拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），singo的老婆就不可能对该记录进行修改，也就是singo的老婆不能在此时转账。</li><li>04：重复读可能出现<a href="https://so.csdn.net/so/search?q=%E5%B9%BB%E8%AF%BB&spm=1001.2101.3001.7020">幻读</a>： singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month &#x3D; 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出现了幻觉，幻读就这样产生了。（幻读是事务执行过程中，别的事务进行插入操作，从而使原来的查询事务出现“幻觉”）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL | 日志系统</title>
    <link href="/2023/06/05/02%E8%AE%B2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/06/05/02%E8%AE%B2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>首先介绍两个日志的基本概念，一个是物理操作，一个是逻辑操作。</p><ul><li><p>物理操作</p><p>  物理操作是对数据库底层数据存储结构的操作，即对数据在物理存储设备上的读写操作，例如读取和写入具体的数据块、页或者记录等。物理操作直接访问存储设备，包括对设备的读取、写入、删除操作等，因此它对应着实际的存储结构。 因为redolog是Innodb中特有的日志，又因为存储引擎在最底层，所以redolog是物理操作。</p></li><li><p>逻辑操作</p><p>  逻辑操作是对数据库中对象的操作，例如对表中数据的增删改查等操作，它是基于用户或应用程序想要执行的实际操作进行的操作。逻辑操作是以SQL语言的形式体现的，根据不同的SQL语句可以进行增删改查等逻辑操作，而不考虑数据的存储细节和实际操作过程。因为binlog是mysql中自带的，所以在上层，只能进行逻辑操作的记录。</p></li></ul><p>接下来来讲两个日志，一个是redolog，一个是binlog。</p><ul><li><p>redolog（主要作用是crash-safe）</p><p>  redolog出现的目的是完成事物的一致性，当事务进行到一半的时候mysql突然崩溃了，redolog可以进行回滚操作，它本身是以二进制的方式存储的。还有一个持久化的目的，因为每次想把操作持久化都要进行磁盘的读写，但是磁盘读写太慢了，所以先在内存记录下来，当系统不忙的时候在写到磁盘上去。其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging。因为redolog是物理操作，所以存的都是结果如何变更，不会存具体的逻辑。它的存储方式如下图：</p><p>  checkpoint表示从哪里开始，write pos表示在哪里结束</p><p>  <img src="https://secure2.wostatic.cn/static/6QEVzctFnb9hojQNRBAch6/image.png?auth_key=1686117503-gu4RodEvCheszVu7tv2Xyc-0-ab77d042d9fde44e305ee1556f04c3d5&file_size=149386"></p></li><li><p>binlog（主要作用是归档，即回到某一个时间点的数据库状态）</p><p>  底层使用二进制存储的语句逻辑，加入想回到中午那时候的数据库，就需要找到中午之前最近的全局备份，然后执行binlog到中午即可。</p><p>  常见的 binlog 格式有三种：statement、row 和 mixed，不同格式的 binlog 会记录不同粒度的信息。</p><ul><li>statement 格式是最常见的 binlog 格式，它记录的是 SQL 语句的执行信息。也就是说，如果一个 SQL 语句要修改多行数据，那它只需要记录这条语句本身，而不需要记录每行数据的修改情况。这种格式下日志量小，但是存在一定的不一致性。</li><li>row 格式记录的是每一行数据修改的详细情况，一条修改命令会被具体记录为几条将要修改数据的语句。这种格式下数据更为详细，但是日志量较大。</li><li>mixed 格式在 statement 和 row 格式之间切换，刚开始以 statement 方式记录日志，当出现不支持语句级别的操作时，会自动转化为 row 格式记录。mixed 格式将 statement 和 row 格式的优点结合起来，同时也存在对应的缺点。</li></ul></li></ul><p>这两个日志相结合，使用的时候需要保证一致性，如果在两个日志中间crash了，保证不了一致性，所以引入了一个类似事务的操作，如下图：</p><p>将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p><p><img src="https://secure2.wostatic.cn/static/cAC2ALzsaU3uzNME5igau5/image.png?auth_key=1686117517-jseHsfnzAHfkmNZr2AHqsP-0-2a0a1282a639b22d8219759c42ab0301&file_size=549965"></p><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客操作指南</title>
    <link href="/2023/06/04/%E5%8D%9A%E5%AE%A2%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <url>/2023/06/04/%E5%8D%9A%E5%AE%A2%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>第一篇文章就先把怎么更新博客说明白吧，就当写个时间胶囊，以防自己忘了😅 ，本篇文章只适合hexo已经搭建好博客，但是不知道怎么更新的人，网上关于搭建hexo博客的文章也挺多的。</p><p>经过滴滴二面面试官的拷打，我已痛定思痛，开始写技术博客，并且开始注重理论和实践的相结合。</p><ol><li>首先找到自己的blog文件夹（我的blog文件在E盘下），用vscode打开之后找到source下面的_posts文件夹，你的文章就以markdown形式储存在这，你可以先用wolai云笔记记录，之后贴到这里，双重保险不怕丢了，这里主要介绍一下怎么给文章分类和打tag吧。下面这段东西在表头粘上就行</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Go">---<br>title: Your Article Title<br>date: YYYY-MM-DD HH:MM:SS<br>categories:<br>  - Category1<br>  - Category2<br>tags:<br>  - Tag1<br>  - Tag2<br>---<br></code></pre></td></tr></table></figure><p>2.把文章写进去之后如何推到远端呢，通过下面这三个命令即可，顺序不能乱，原因看完就知道了</p><ul><li><p>hexo g</p><p>  是hexo generate的缩写，把博客文件夹下面的文章转换成HTML静态页面，这些静态页面储存在博客文件夹下的public下面</p></li><li><p>hexo s</p><p>  是hexo server的缩写，把文件夹下的文章在本地的服务器启动，默认端口4000，这时就可以看页面是否符合你的要求，如果符合的话就可以推送到远端了</p></li><li><p>hexo d</p><p>  是hexo deploy的缩写，把页面推送到博客托管平台，一些配置在config下</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
